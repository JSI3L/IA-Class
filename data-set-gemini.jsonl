{"prompt": "¿Cuál es la forma más rápida de iterar sobre una lista en Python y por qué?", "response": "La forma más común y \"pythonic\" es usar un bucle `for` directamente con la lista: `for elemento in mi_lista:`. Es rápido porque internamente usa iteradores optimizados de C y es más legible que usar `range(len(mi_lista))`."}
{"prompt": "Escribe una función en Python para calcular el factorial de un número de forma recursiva.", "response": "Aquí tienes la función:\n```python\ndef factorial_recursivo(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial_recursivo(n-1)\n```"}
{"prompt": "Explica la diferencia entre `list` y `tuple` en Python.", "response": "La principal diferencia es que las **listas** son **mutables** (puedes añadir, eliminar o modificar elementos después de su creación), mientras que las **tuplas** son **inmutables** (su contenido no se puede cambiar una vez creadas). Las tuplas suelen ser más rápidas y se usan para datos que no deben cambiar."}
{"prompt": "Tengo este código: `x = 10; y = 20; print(x + y)`. ¿Cómo lo harías más eficiente?", "response": "Tu código ya es muy eficiente para lo que hace. En este caso, la **legibilidad** es más importante que micro-optimizar la suma de dos números. Si estuvieras dentro de un bucle con millones de iteraciones, podríamos buscar optimizaciones a nivel de algoritmo."}
{"prompt": "¿Qué es un **decorador** en Python y dame un ejemplo simple?", "response": "Un **decorador** es un patrón de diseño que permite añadir funcionalidad a una función o método existente sin modificar su estructura. Se usan con el símbolo `@`. \n\nEjemplo de un decorador simple que imprime un mensaje:\n```python\ndef mi_decorador(funcion):\n    def envoltura():\n        print('¡Algo está a punto de suceder!')\n        funcion()\n        print('¡Acaba de suceder!')\n    return envoltura\n\n@mi_decorador\ndef saludar():\n    print('¡Hola!')\n\nsaludar()\n# Salida:\n# ¡Algo está a punto de suceder!\n# ¡Hola!\n# ¡Acaba de suceder!\n```"}
{"prompt": "Dame el código para leer un archivo CSV llamado 'datos.csv' usando la librería `pandas`.", "response": "Puedes usar la función `read_csv()` de pandas:\n```python\nimport pandas as pd\ndf = pd.read_csv('datos.csv')\nprint(df.head())\n```"}
{"prompt": "¿Cómo manejo las excepciones en Python? Dame un ejemplo con `try` y `except`.", "response": "Se usa el bloque `try...except`:\n```python\ntry:\n    resultado = 10 / 0\nexcept ZeroDivisionError:\n    print('Error: No se puede dividir por cero.')\nexcept Exception as e:\n    print(f'Ocurrió otro error: {e}')\n```"}
{"prompt": "¿Qué es la **comprensión de listas** (List Comprehension)?", "response": "Es una forma concisa y elegante de crear listas en Python. Permite crear una nueva lista aplicando una expresión a cada elemento de una secuencia o iterable y, opcionalmente, filtrando los elementos. \n\nEjemplo: `cuadrados = [x**2 for x in range(10) if x % 2 == 0]`"}
{"prompt": "Necesito crear una clase `Coche` con atributos `color` y `velocidad`. ¿Cómo se inicializa?", "response": "Usarás el método especial `__init__`:\n```python\nclass Coche:\n    def __init__(self, color, velocidad=0):\n        self.color = color\n        self.velocidad = velocidad\n\nmi_coche = Coche('rojo', 60)\nprint(mi_coche.color) # Salida: rojo\n```"}
{"prompt": "¿Cuál es la diferencia entre los métodos `GET` y `POST` en el contexto de una API en Python (usando Flask o Django)?", "response": "El método **GET** se usa para **solicitar o recuperar** datos de un recurso específico (es decir, solo para leer). El método **POST** se usa para **enviar datos** al servidor para crear o actualizar un recurso. `GET` no modifica el estado del servidor, `POST` sí."}
{"prompt": "Escribe un ejemplo de cómo conectar a una base de datos SQLite en Python.", "response": "```python\nimport sqlite3\n\nconn = sqlite3.connect('ejemplo.db')\ncursor = conn.cursor()\n\n# Crear una tabla\ncursor.execute('CREATE TABLE IF NOT EXISTS usuarios (id INTEGER, nombre TEXT)')\n\n# Insertar datos\ncursor.execute(\"INSERT INTO usuarios VALUES (1, 'Alice')\")\nconn.commit()\n\nconn.close()\n```"}
{"prompt": "¿Cómo hago que una variable sea **global** dentro de una función en Python?", "response": "Usas la palabra clave `global`:\n```python\nx = 5\ndef mi_funcion():\n    global x\n    x = 10  # Modifica la variable global\n\nmi_funcion()\nprint(x) # Salida: 10\n```"}
{"prompt": "Explica brevemente qué es el **GIL** (Global Interpreter Lock) en CPython.", "response": "El **GIL** es un mecanismo en el intérprete CPython que asegura que solo **un hilo** de Python ejecute código de *bytecode* Python a la vez. Esto simplifica la gestión de memoria y evita problemas de concurrencia, pero limita la ejecución paralela de código Python puro en CPUs con múltiples núcleos."}
{"prompt": "Necesito un `script` que recorra una carpeta y liste todos los archivos con extensión `.txt`.", "response": "Puedes usar la librería `os`:\n```python\nimport os\n\ndirectorio = './mi_carpeta'\nfor archivo in os.listdir(directorio):\n    if archivo.endswith('.txt'):\n        print(archivo)\n```"}
{"prompt": "¿Qué es `self` en los métodos de una clase en Python?", "response": "`self` es una convención (no es una palabra clave reservada) para referirse a la **instancia** del objeto. Es el primer argumento que debe recibir cualquier método de instancia, y le permite al método acceder a los atributos y otros métodos específicos de esa instancia."}
{"prompt": "¿Cómo instalo un paquete en Python usando `pip`?", "response": "Abres la terminal o línea de comandos y ejecutas: `pip install nombre-del-paquete` (por ejemplo, `pip install requests`)."}
{"prompt": "Escribe un generador simple en Python que produzca los primeros 5 números pares.", "response": "```python\ndef generar_pares():\n    n = 0\n    while n < 10:\n        yield n\n        n += 2\n\nfor par in generar_pares():\n    print(par) # Salida: 0, 2, 4, 6, 8\n```"}
{"prompt": "¿Cuál es la diferencia entre `==` y `is` en Python?", "response": "`==` compara el **valor** de dos objetos. `is` compara la **identidad** de dos objetos, es decir, si ambos apuntan a la misma ubicación de memoria (si son el mismo objeto).\n\nEjemplo: `a = [1]; b = [1]`. `a == b` es **True**, pero `a is b` es **False**."}
{"prompt": "Quiero mezclar los elementos de una lista de forma aleatoria. ¿Qué módulo y función uso?", "response": "Usarás el módulo `random` y la función `random.shuffle()`:\n```python\nimport random\nlista = [1, 2, 3, 4, 5]\nrandom.shuffle(lista)\nprint(lista) # El orden será aleatorio\n```"}
{"prompt": "Explica qué es un **argpack** (`*args`) y un **kwargpack** (`**kwargs`) en una definición de función.", "response": "`*args` permite pasar un número variable de **argumentos posicionales** a una función, que se reciben como una tupla. `**kwargs` permite pasar un número variable de **argumentos de palabra clave** (keywords), que se reciben como un diccionario."}
{"prompt": "¿Cómo defino un *setter* y un *getter* para un atributo en una clase Python?", "response": "La forma moderna es usando la propiedad `@property` para el *getter* y `@<atributo>.setter` para el *setter*:\n```python\nclass Persona:\n    def __init__(self, nombre):\n        self._nombre = nombre\n\n    @property\n    def nombre(self):\n        return self._nombre\n\n    @nombre.setter\n    def nombre(self, nuevo_nombre):\n        if len(nuevo_nombre) > 0:\n            self._nombre = nuevo_nombre\n```"}
{"prompt": "¿Qué son los *docstrings* y por qué son importantes?", "response": "Los *docstrings* son cadenas literales que aparecen como la primera instrucción en un módulo, clase, función o método. Se usan para **documentar** el propósito, funcionamiento y uso del código. Son importantes porque herramientas como `help()` o generadores de documentación como Sphinx pueden leerlos y presentarlos al usuario."}
{"prompt": "¿Cómo convierto un diccionario de Python a una cadena JSON?", "response": "Usas la función `json.dumps()` del módulo `json`:\n```python\nimport json\ndiccionario = {'clave': 'valor'}\njson_string = json.dumps(diccionario)\nprint(json_string)\n```"}
{"prompt": "Dame el comando para iniciar un entorno virtual en Python y activarlo en Linux/macOS.", "response": "Primero crea el entorno: `python3 -m venv mi_entorno`. Luego actívalo: `source mi_entorno/bin/activate`."}
{"prompt": "Escribe un *one-liner* para invertir una cadena de texto en Python.", "response": "Puedes usar la técnica de *slicing* extendido: `cadena_invertida = mi_cadena[::-1]`."}
{"prompt": "¿Qué es un **módulo** en Python?", "response": "Un **módulo** es simplemente un archivo Python (`.py`) que contiene definiciones de funciones, clases y variables. Permite organizar el código y reutilizarlo importándolo en otros archivos."}
{"prompt": "¿Cómo se realiza la herencia en clases de Python?", "response": "Se indica la clase padre entre paréntesis al definir la clase hija:\n```python\nclass Animal:\n    def hablar(self):\n        pass\n\nclass Perro(Animal):\n    def hablar(self):\n        return 'Guau'\n```"}
{"prompt": "Tengo un número `num = 15`. Quiero imprimir 'Fizz' si es divisible por 3, 'Buzz' si es divisible por 5, y 'FizzBuzz' si es divisible por ambos.", "response": "```python\nnum = 15\nsalida = ''\nif num % 3 == 0:\n    salida += 'Fizz'\nif num % 5 == 0:\n    salida += 'Buzz'\nprint(salida or num)\n```"}
{"prompt": "¿Cuál es la función del método `__str__` en una clase?", "response": "El método `__str__` define cómo debe representarse una instancia de la clase como una **cadena legible** para el usuario. Es llamado por la función `print()`."}
{"prompt": "Diferencia entre `break` y `continue` en un bucle.", "response": "`break` **detiene** completamente la ejecución del bucle. `continue` **salta** la iteración actual y pasa a la siguiente."}
{"prompt": "¿Cómo puedo ordenar una lista de diccionarios por el valor de una clave específica?", "response": "Usando la función `sorted()` con el argumento `key` y una función `lambda`:\n```python\ndatos = [{'nombre': 'B', 'edad': 30}, {'nombre': 'A', 'edad': 20}]\nordenado = sorted(datos, key=lambda x: x['edad'])\n# ordenado será: [{'nombre': 'A', 'edad': 20}, {'nombre': 'B', 'edad': 30}]\n```"}
{"prompt": "¿Qué es un `set` en Python?", "response": "Un `set` (conjunto) es una colección **no ordenada** de elementos **únicos** e **inmutables**. Se utiliza para eliminar duplicados y realizar operaciones de conjuntos como unión, intersección y diferencia."}
{"prompt": "Escribe una función que acepte una lista de números y devuelva solo los números primos.", "response": "```python\ndef es_primo(n):\n    if n < 2: return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef filtrar_primos(lista):\n    return [num for num in lista if es_primo(num)]\n```"}
{"prompt": "¿Cómo puedo medir el tiempo que tarda mi código Python en ejecutarse?", "response": "Usas el módulo `time` con la función `time.time()` o el módulo `timeit` para una medición más precisa.\n```python\nimport time\nstart_time = time.time()\n# código a medir\nend_time = time.time()\nprint(f\"Tiempo de ejecución: {end_time - start_time} segundos\")\n```"}
{"prompt": "Explica el concepto de **polimorfismo** en programación orientada a objetos (POO).", "response": "El **polimorfismo** (muchas formas) se refiere a la capacidad de un objeto de tomar varias formas o, más concretamente, la capacidad de diferentes clases para responder al mismo mensaje o método de maneras distintas."}
{"prompt": "¿Qué es el *f-string* en Python?", "response": "El *f-string* (cadenas literales con formato) es una forma introducida en Python 3.6 para **incrustar expresiones** dentro de cadenas literales de forma concisa y legible. Se definen prefijando la cadena con la letra `f`.\n\nEjemplo: `nombre = 'Alice'; edad = 30; print(f'Me llamo {nombre} y tengo {edad} años.')`"}
{"prompt": "¿Cómo puedo evitar un error si una clave no existe en un diccionario?", "response": "Puedes usar el método `dict.get(clave, valor_por_defecto)` que devuelve un valor predeterminado si la clave no se encuentra, o usar un bloque `try-except`."}
{"prompt": "Escribe una expresión regular en Python para encontrar todas las direcciones de correo electrónico en una cadena de texto.", "response": "```python\nimport re\ntexto = \"Contacto: test@ejemplo.com\"\npatron = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\ncorreos = re.findall(patron, texto)\nprint(correos)\n```"}
{"prompt": "¿Cuál es la función del método `super()` en la herencia?", "response": "`super()` permite a una clase hija llamar a un método de su clase padre (o una clase ancestral), comúnmente usado en `__init__` para asegurar que el constructor de la clase padre se inicialice correctamente."}
{"prompt": "Dame el código para invertir un diccionario, intercambiando claves por valores.", "response": "```python\ndiccionario = {'a': 1, 'b': 2, 'c': 3}\ninvertido = {valor: clave for clave, valor in diccionario.items()}\nprint(invertido)\n```"}
{"prompt": "¿Qué es un *lambda* en Python?", "response": "Un *lambda* (o función anónima) es una pequeña función que se define con la palabra clave `lambda`. Está limitada a una única expresión y se utiliza a menudo para argumentos de funciones de orden superior (como `map`, `filter`, `sorted`)."}
{"prompt": "¿Cómo puedo escribir datos en un archivo de texto llamado 'salida.txt'?", "response": "Usando la palabra clave `with` para asegurar que el archivo se cierre correctamente, y el modo `'w'` (write):\n```python\nwith open('salida.txt', 'w') as f:\n    f.write('Esta es la primera línea.\\n')\n    f.write('Esta es la segunda línea.')\n```"}
{"prompt": "¿Cómo elimino los elementos duplicados de una lista sin cambiar el orden original (si es posible)?", "response": "La forma más simple de eliminar duplicados es convertir la lista a un `set` y luego de vuelta a `list`. Si el orden es crucial, se puede usar un bucle o un `OrderedDict` (aunque el primero es más común para mantener el orden):\n```python\nmi_lista = [1, 3, 2, 3, 1]\n# Opción simple (pierde orden):\nlista_sin_duplicados = list(set(mi_lista))\n# Opción para mantener orden:\nlista_sin_duplicados = []\nfor item in mi_lista:\n    if item not in lista_sin_duplicados:\n        lista_sin_duplicados.append(item)\n```"}
{"prompt": "¿Cuál es la diferencia entre un **módulo** y un **paquete**?", "response": "Un **módulo** es un solo archivo Python (`.py`). Un **paquete** es una colección de módulos (y subpaquetes) organizados en directorios, que debe incluir un archivo especial (históricamente `__init__.py`, aunque en Python 3.3+ ya no es estrictamente necesario para paquetes simples)."}
{"prompt": "Tengo una lista `[1, 2, 3, 4]`. ¿Cómo la convierto a una cadena '1-2-3-4'?", "response": "Primero conviertes los números a cadenas y luego usas el método `str.join()`:\n```python\nlista_nums = [1, 2, 3, 4]\ncadena = '-'.join(map(str, lista_nums))\nprint(cadena) # Salida: '1-2-3-4'\n```"}
{"prompt": "¿Qué es el *tipado dinámico* de Python?", "response": "El **tipado dinámico** significa que la verificación de tipos (que una variable sea un entero, una cadena, etc.) se realiza en **tiempo de ejecución**, no en tiempo de compilación. Las variables no tienen un tipo fijo; su tipo puede cambiar a medida que se les asignan diferentes valores."}
{"prompt": "Explica la diferencia entre un bucle `while` y un bucle `for`.", "response": "Un bucle `for` se usa típicamente para **iterar** sobre una secuencia (lista, tupla, cadena, etc.) un **número predefinido** de veces. Un bucle `while` se usa para repetir un bloque de código **mientras** una condición sea verdadera, y se usa cuando no se sabe de antemano cuántas iteraciones se necesitarán."}
{"prompt": "Necesito un `snippet` para hacer una petición HTTP GET simple y mostrar el estado de la respuesta (usando la librería `requests`).", "response": "```python\nimport requests\n\nurl = '[https://api.github.com/events](https://api.github.com/events)'\nrespuesta = requests.get(url)\nprint(f\"Código de estado: {respuesta.status_code}\")\n```"}
{"prompt": "¿Qué son los *list/dict/set/tuple comprehensions*?", "response": "Son formas concisas y eficientes de crear `listas`, `diccionarios`, `conjuntos` y `tuplas` (aunque la comprensión de tuplas crea un generador) en una sola línea. Permiten crear estas estructuras de datos aplicando una expresión a cada elemento de un iterable existente, con un filtro opcional."}
{"prompt": "¿Cuál es la mejor práctica para nombrar variables en Python (PEP 8)?", "response": "La convención de nomenclatura estándar (PEP 8) es usar **`snake_case`** (todo en minúsculas y palabras separadas por guiones bajos) para variables, funciones, métodos y módulos. Las Clases deben usar **`CapWords`** (CamelCase)."}
